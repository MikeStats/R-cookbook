# Vector basics {#variables}

```{r include=FALSE}
# Every file must contain at least one R chunk due to the linting process.
```

## Coercion
There are four main atomic vector types that you are likely to come across
when using R^[technically there are more, see 
https://adv-r.hadley.nz/vectors-chap.html#atomic-vectors]; logical (`TRUE` or 
`FALSE`), double (`1.5`), integer (`1L, 2L`)^[without the post-fix `L`, the 
value would be stored as a double], and character (`"Awesome"`).

Converting between the vector types is done using the `as.character`, 
`as.integer`, `as.logical` and `as.double` functions.

```{r}
value <- 1.5
as.integer(value)
as.character(value)
as.logical(value)
```

Where it is not possible to convert a value you will get a warning message

```{r}
value <- "z"
as.integer(value)
```

When combining different vector types, coercion will obey the following 
hierarchy: character, double, integer, logical.

```{r}
typeof(c(9.9, 3L, "pop", TRUE))
typeof(c(9.9, 3L, TRUE))
typeof(c(3L, TRUE))
typeof(TRUE)
```

## Factors

## Dates

## Rounding
For rounding numerical values we have the function `round(x, digits = 0)`.  
This rounds the value of the first argument to the specified number of decimal 
places (default 0).

```{r}
round(c(-1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5))
```

This probably looks different to what you were expecting as at school we were 
generally taught that when rounding a 5 we go up if a positive value and down if
a negative value.  R, however, implements a different standard.  We can see this
by looking at the documentation (`?round`)

> Note that for rounding off a 5, the IEC 60559 standard (see also ‘IEEE 754’) 
is expected to be used, *‘go to the even digit’*. Therefore `round(0.5)` is `0` 
and `round(-1.5)` is `-2`. However, this is dependent on OS services and on 
representation error (since e.g. `0.15` is not represented exactly, the
rounding rule applies to the represented number and not to the printed number, 
and so `round(0.15, 1)` could be either `0.1` or `0.2`).

To implement what we consider normal rounding we can install use the `janitor`
package and the function `round_half_up`

```{r, warning=FALSE}
# install.packages("janitor") # (if not already installed)
library(janitor)
janitor::round_half_up(c(-1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5))
```

If we do not have access to the package (or do not want to depend on the 
package) then we can implement^[see [stackoverflow](https://stackoverflow.com/questions/12688717/round-up-from-5/12688836#12688836)
discussion for the implementation] the function directly

```{r}
round_half_up <- function(x, digits = 0) {
  posneg <- sign(x)
  z <- abs(x) * 10 ^ digits
  z <- z + 0.5
  z <- trunc(z)
  z <- z / 10 ^ digits
  z * posneg
}
```

