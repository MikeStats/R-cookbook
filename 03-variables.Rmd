```{r include=FALSE}
knitr::opts_chunk$set(collapse=TRUE, comment="#>")
```

# Vector basics {#variables}

## Vector types
There are four main atomic vector types that you are likely to come across
when using R^[technically there are more, see 
https://adv-r.hadley.nz/vectors-chap.html#atomic-vectors]; **logical** (`TRUE` 
or `FALSE`), *double* (`3.142`), *integer* (`2L`) and *character* (`"Awesome"`)

```{r}
v1 <- TRUE
typeof(v1)
v1 <- FALSE
typeof(v1)

v2 <- 1.5
typeof(v2)
v2 <- 1
typeof(v2)

# integer values must be followed by an L to be stored as integers
v3 <- 2
typeof(v3)
v3 <- 2L
typeof(v3)

v4 <- "Awesome"
typeof(v4)
```

As well as the atomic vector types you will often encounter two other vector
types; **factor** and **Date**.  

Factor vectors are used to represent categorical data.  They are actually
integer vectors with two additional attributes, levels and class.  At this
stage it is not worth worrying to much about what attribute are just understand
that, for factors, the levels attribute gives the possible categories and 
combined with the integer values works much like a lookup table.  The `class` 
attribute is just "factor".


```{r}
ratings <- factor(c("good", "bad", "bad", "amazing"))
typeof(ratings)
attributes(ratings)
```

Date vectors are just double vectors with an additional class attribute set as
"Date".  

**Note - The following borrows directly from Hadley's Advanced R site
so we need to attribute appropriately and use correct licence**

```{r}
today <- Sys.Date()
typeof(today)
attributes(today)
```

The value of the double (which can be seen by stripping the class), represents
the number of days since "1970-01-01"^[This special date is known as the Unix 
Epoch]:

```{r}
date <- as.Date("1970-02-01")
unclass(date)
```

## Coercion

### Conversion between atomic vector types

Converting between the atomic vector types is done using the `as.character`, 
`as.integer`, `as.logical` and `as.double` functions.

```{r}
value <- 1.5
as.integer(value)
as.character(value)
as.logical(value)
```

Where it is not possible to convert a value you will get a warning message

```{r}
value <- "z"
as.integer(value)
```

When combining different vector types, coercion will obey the following 
hierarchy: character, double, integer, logical.

```{r}
typeof(c(9.9, 3L, "pop", TRUE))
typeof(c(9.9, 3L, TRUE))
typeof(c(3L, TRUE))
typeof(TRUE)
```

### Conversions with factors
Unfortunately factors can be tricky to work with and their behaviour is not
always obvious.  Below we illustrate a couple of things to bear in mind when
working with them.  Firstly concatenating factors may not work as intended:

```{r}
my_factor <- factor(c("bob", "george", "bob"))
my_vector <- c(my_factor, my_factor)
my_vector
```

instead we would first need to convert to a character vector

```{r}
my_vector_2 <- c(as.character(my_factor), as.character(my_factor))
my_vector_2
```

Secondly, we may sometimes find a numeric vector is being stored as a factor:

```{r}
df <- read.csv("data/factor_example.csv")
my_vector <- df[[2]]
typeof(my_vector)
my_vector
```

to transform this to a numeric variable we can proceed as follows
```{r}
my_vector_2 <- as.numeric(levels(my_vector)[my_vector])
typeof(my_vector_2)
my_vector_2
```

## Working with dates
**NOT FINISHED - need to write about `lubridate`**

## Working with factors
**NOT FINISHED - need to write about `forcats`**


## Rounding
For rounding numerical values we have the function `round(x, digits = 0)`.  
This rounds the value of the first argument to the specified number of decimal 
places (default 0).

```{r}
round(c(-1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5))
```

This probably looks different to what you were expecting as at school we were 
generally taught that when rounding a 5 we go up if a positive value and down if
a negative value.  R, however, implements a different standard.  We can see this
by looking at the documentation (`?round`)

> Note that for rounding off a 5, the IEC 60559 standard (see also ‘IEEE 754’) 
is expected to be used, *‘go to the even digit’*. Therefore `round(0.5)` is `0` 
and `round(-1.5)` is `-2`. However, this is dependent on OS services and on 
representation error (since e.g. `0.15` is not represented exactly, the
rounding rule applies to the represented number and not to the printed number, 
and so `round(0.15, 1)` could be either `0.1` or `0.2`).

To implement what we consider normal rounding we can install use the `janitor`
package and the function `round_half_up`

```{r, warning=FALSE}
library(janitor)
janitor::round_half_up(c(-1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5))
```

If we do not have access to the package (or do not want to depend on the 
package) then we can implement^[see [stackoverflow](https://stackoverflow.com/questions/12688717/round-up-from-5/12688836#12688836)
discussion for a discussion of the implementation]

```{r}
round_half_up_v2 <- function(x, digits = 0) {
  posneg <- sign(x)
  z <- abs(x) * 10 ^ digits
  z <- z + 0.5
  z <- trunc(z)
  z <- z / 10 ^ digits
  z * posneg
}

round_half_up_v2(c(-1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5))
```

