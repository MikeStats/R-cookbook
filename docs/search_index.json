[
["variables.html", "Chapter 4 Vector basics 4.1 Coercion 4.2 Factors 4.3 Dates 4.4 Rounding", " Chapter 4 Vector basics 4.1 Coercion There are four main atomic vector types that you are likely to come across when using R1; logical (TRUE or FALSE), double (1.5), integer (1L, 2L)2, and character (\"Awesome\"). Converting between the vector types is done using the as.character, as.integer, as.logical and as.double functions. value &lt;- 1.5 as.integer(value) ## [1] 1 as.character(value) ## [1] &quot;1.5&quot; as.logical(value) ## [1] TRUE Where it is not possible to convert a value you will get a warning message value &lt;- &quot;z&quot; as.integer(value) ## Warning: NAs introduced by coercion ## [1] NA When combining different vector types, coercion will obey the following hierarchy: character, double, integer, logical. typeof(c(9.9, 3L, &quot;pop&quot;, TRUE)) ## [1] &quot;character&quot; typeof(c(9.9, 3L, TRUE)) ## [1] &quot;double&quot; typeof(c(3L, TRUE)) ## [1] &quot;integer&quot; typeof(TRUE) ## [1] &quot;logical&quot; 4.2 Factors 4.3 Dates 4.4 Rounding For rounding numerical values we have the function round(x, digits = 0). This rounds the value of the first argument to the specified number of decimal places (default 0). round(c(-1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5)) ## [1] -2 0 0 2 2 4 4 This probably looks different to what you were expecting as at school we were generally taught that when rounding a 5 we go up if a positive value and down if a negative value. R, however, implements a different standard. We can see this by looking at the documentation (?round) Note that for rounding off a 5, the IEC 60559 standard (see also ‘IEEE 754’) is expected to be used, ‘go to the even digit’. Therefore round(0.5) is 0 and round(-1.5) is -2. However, this is dependent on OS services and on representation error (since e.g. 0.15 is not represented exactly, the rounding rule applies to the represented number and not to the printed number, and so round(0.15, 1) could be either 0.1 or 0.2). To implement what we consider normal rounding we can install use the janitor package and the function round_half_up # install.packages(&quot;janitor&quot;) # (if not already installed) library(janitor) janitor::round_half_up(c(-1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5)) ## [1] -2 -1 1 2 3 4 5 If we do not have access to the package (or do not want to depend on the package) then we can implement3 the function directly round_half_up &lt;- function(x, digits = 0) { posneg &lt;- sign(x) z &lt;- abs(x) * 10 ^ digits z &lt;- z + 0.5 z &lt;- trunc(z) z &lt;- z / 10 ^ digits z * posneg } technically there are more, see https://adv-r.hadley.nz/vectors-chap.html#atomic-vectors↩ without the post-fix L, the value would be stored as a double↩ see stackoverflow discussion for the implementation↩ "]
]
