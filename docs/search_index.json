[
["variables.html", "Chapter 4 Vector basics 4.1 Vector types 4.2 Coercion 4.3 Working with dates 4.4 Working with factors 4.5 Rounding", " Chapter 4 Vector basics 4.1 Vector types There are four main atomic vector types that you are likely to come across when using R1; logical (TRUE or FALSE), double (3.142), integer (2L) and character (\"awesome\") v1 &lt;- TRUE typeof(v1) #&gt; [1] &quot;logical&quot; v1 &lt;- FALSE typeof(v1) #&gt; [1] &quot;logical&quot; v2 &lt;- 1.5 typeof(v2) #&gt; [1] &quot;double&quot; v2 &lt;- 1 typeof(v2) #&gt; [1] &quot;double&quot; # integer values must be followed by an L to be stored as integers v3 &lt;- 2 typeof(v3) #&gt; [1] &quot;double&quot; v3 &lt;- 2L typeof(v3) #&gt; [1] &quot;integer&quot; v4 &lt;- &quot;Awesome&quot; typeof(v4) #&gt; [1] &quot;character&quot; As well as the atomic vector types you will often encounter two other vector types; factor and Date. Factor vectors are used to represent categorical data. They are actually integer vectors with two additional attributes, levels and class. At this stage it is not worth worrying to much about what attribute are just understand that, for factors, the levels attribute gives the possible categories and combined with the integer values works much like a lookup table. The class attribute is just “factor”. ratings &lt;- factor(c(&quot;good&quot;, &quot;bad&quot;, &quot;bad&quot;, &quot;amazing&quot;)) typeof(ratings) #&gt; [1] &quot;integer&quot; attributes(ratings) #&gt; $levels #&gt; [1] &quot;amazing&quot; &quot;bad&quot; &quot;good&quot; #&gt; #&gt; $class #&gt; [1] &quot;factor&quot; Date vectors are just double vectors with an additional class attribute set as “Date”. Note - The following borrows directly from Hadley’s Advanced R site so we need to attribute appropriately and use correct licence today &lt;- Sys.Date() typeof(today) #&gt; [1] &quot;double&quot; attributes(today) #&gt; $class #&gt; [1] &quot;Date&quot; The value of the double (which can be seen by stripping the class), represents the number of days since “1970-01-01”2: date &lt;- as.Date(&quot;1970-02-01&quot;) unclass(date) #&gt; [1] 31 4.2 Coercion 4.2.1 Conversion between atomic vector types Converting between the atomic vector types is done using the as.character, as.integer, as.logical and as.double functions. value &lt;- 1.5 as.integer(value) #&gt; [1] 1 as.character(value) #&gt; [1] &quot;1.5&quot; as.logical(value) #&gt; [1] TRUE Where it is not possible to convert a value you will get a warning message value &lt;- &quot;z&quot; as.integer(value) #&gt; Warning: NAs introduced by coercion #&gt; [1] NA When combining different vector types, coercion will obey the following hierarchy: character, double, integer, logical. typeof(c(9.9, 3L, &quot;pop&quot;, TRUE)) #&gt; [1] &quot;character&quot; typeof(c(9.9, 3L, TRUE)) #&gt; [1] &quot;double&quot; typeof(c(3L, TRUE)) #&gt; [1] &quot;integer&quot; typeof(TRUE) #&gt; [1] &quot;logical&quot; 4.2.2 Conversions with factors Unfortunately factors can be tricky to work with and their behaviour is not always obvious. Below we illustrate a couple of things to bear in mind when working with them. Firstly concatenating factors may not work as intended: my_factor &lt;- factor(c(&quot;bob&quot;, &quot;george&quot;, &quot;bob&quot;)) my_vector &lt;- c(my_factor, my_factor) my_vector #&gt; [1] 1 2 1 1 2 1 instead we would first need to convert to a character vector my_vector_2 &lt;- c(as.character(my_factor), as.character(my_factor)) my_vector_2 #&gt; [1] &quot;bob&quot; &quot;george&quot; &quot;bob&quot; &quot;bob&quot; &quot;george&quot; &quot;bob&quot; Secondly, we may sometimes find a numeric vector is being stored as a factor: df &lt;- read.csv(&quot;data/factor_example.csv&quot;) my_vector &lt;- df[[2]] typeof(my_vector) #&gt; [1] &quot;integer&quot; my_vector #&gt; [1] #N/A #N/A 1 2 3 1 #N/A #N/A #N/A #&gt; Levels: #N/A 1 2 3 to transform this to a numeric variable we can proceed as follows my_vector_2 &lt;- as.numeric(levels(my_vector)[my_vector]) #&gt; Warning: NAs introduced by coercion typeof(my_vector_2) #&gt; [1] &quot;double&quot; my_vector_2 #&gt; [1] NA NA 1 2 3 1 NA NA NA 4.3 Working with dates NOT FINISHED - need to write about lubridate 4.4 Working with factors NOT FINISHED - need to write about forcats 4.5 Rounding For rounding numerical values we have the function round(x, digits = 0). This rounds the value of the first argument to the specified number of decimal places (default 0). round(c(-1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5)) #&gt; [1] -2 0 0 2 2 4 4 This probably looks different to what you were expecting as at school we were generally taught that when rounding a 5 we go up if a positive value and down if a negative value. R, however, implements a different standard. We can see this by looking at the documentation (?round) Note that for rounding off a 5, the IEC 60559 standard (see also ‘IEEE 754’) is expected to be used, ‘go to the even digit’. Therefore round(0.5) is 0 and round(-1.5) is -2. However, this is dependent on OS services and on representation error (since e.g. 0.15 is not represented exactly, the rounding rule applies to the represented number and not to the printed number, and so round(0.15, 1) could be either 0.1 or 0.2). To implement what we consider normal rounding we can install use the janitor package and the function round_half_up library(janitor) #&gt; #&gt; Attaching package: &#39;janitor&#39; #&gt; The following objects are masked from &#39;package:stats&#39;: #&gt; #&gt; chisq.test, fisher.test janitor::round_half_up(c(-1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5)) #&gt; [1] -2 -1 1 2 3 4 5 If we do not have access to the package (or do not want to depend on the package) then we can implement3 round_half_up_v2 &lt;- function(x, digits = 0) { posneg &lt;- sign(x) z &lt;- abs(x) * 10 ^ digits z &lt;- z + 0.5 z &lt;- trunc(z) z &lt;- z / 10 ^ digits z * posneg } round_half_up_v2(c(-1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5)) #&gt; [1] -2 -1 1 2 3 4 5 technically there are more, see https://adv-r.hadley.nz/vectors-chap.html#atomic-vectors↩ This special date is known as the Unix Epoch↩ see stackoverflow discussion for a discussion of the implementation↩ "]
]
