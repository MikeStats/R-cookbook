[
["variables.html", "Chapter 4 Vector basics 4.1 Vector types 4.2 Coercion 4.3 Factors 4.4 Dates 4.5 Rounding", " Chapter 4 Vector basics 4.1 Vector types There are four main atomic vector types that you are likely to come across when using R1; logical (TRUE or FALSE), double (3.142), integer (2L) and character (\"awesome\") v1 &lt;- TRUE typeof(v1) #&gt; [1] &quot;logical&quot; v1 &lt;- FALSE typeof(v1) #&gt; [1] &quot;logical&quot; v2 &lt;- 1.5 typeof(v2) #&gt; [1] &quot;double&quot; v2 &lt;- 1 typeof(v2) #&gt; [1] &quot;double&quot; # integer values must be followed by an L to be stored as integers v3 &lt;- 2 typeof(v3) #&gt; [1] &quot;double&quot; v3 &lt;- 2L typeof(v3) #&gt; [1] &quot;integer&quot; v4 &lt;- &quot;Awesome&quot; typeof(v4) #&gt; [1] &quot;character&quot; As well as the atomic vector types you will often encounter two other vector types; factor and Date. Factor vectors are used to represent categorical data. They are actually integer vectors with two additional attributes, levels and class. At this stage it is not worth worrying to much about what attribute are just understand that, for factors, the levels attribute gives the possible categories and combined with the integer values works much like a lookup table. The class attribute is just “factor”. ratings &lt;- factor(c(&quot;good&quot;, &quot;bad&quot;, &quot;bad&quot;, &quot;amazing&quot;)) typeof(ratings) #&gt; [1] &quot;integer&quot; attributes(ratings) #&gt; $levels #&gt; [1] &quot;amazing&quot; &quot;bad&quot; &quot;good&quot; #&gt; #&gt; $class #&gt; [1] &quot;factor&quot; Date vectors are just double vectors with an additional class attribute set as “Date” NOT FINISHED 4.2 Coercion 4.2.1 Conversion between atomic vector types Converting between the atomic vector types is done using the as.character, as.integer, as.logical and as.double functions. value &lt;- 1.5 as.integer(value) #&gt; [1] 1 as.character(value) #&gt; [1] &quot;1.5&quot; as.logical(value) #&gt; [1] TRUE Where it is not possible to convert a value you will get a warning message value &lt;- &quot;z&quot; as.integer(value) #&gt; Warning: NAs introduced by coercion #&gt; [1] NA When combining different vector types, coercion will obey the following hierarchy: character, double, integer, logical. typeof(c(9.9, 3L, &quot;pop&quot;, TRUE)) #&gt; [1] &quot;character&quot; typeof(c(9.9, 3L, TRUE)) #&gt; [1] &quot;double&quot; typeof(c(3L, TRUE)) #&gt; [1] &quot;integer&quot; typeof(TRUE) #&gt; [1] &quot;logical&quot; 4.2.2 Conversions with factors NOT FINISHED 4.3 Factors Unfortunately factors can be tricky to work with and their behaviour is not always obvious. Below we illustrate a couple of gotchas2 NOT FINISHED 4.4 Dates NOT FINISHED 4.5 Rounding For rounding numerical values we have the function round(x, digits = 0). This rounds the value of the first argument to the specified number of decimal places (default 0). round(c(-1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5)) #&gt; [1] -2 0 0 2 2 4 4 This probably looks different to what you were expecting as at school we were generally taught that when rounding a 5 we go up if a positive value and down if a negative value. R, however, implements a different standard. We can see this by looking at the documentation (?round) Note that for rounding off a 5, the IEC 60559 standard (see also ‘IEEE 754’) is expected to be used, ‘go to the even digit’. Therefore round(0.5) is 0 and round(-1.5) is -2. However, this is dependent on OS services and on representation error (since e.g. 0.15 is not represented exactly, the rounding rule applies to the represented number and not to the printed number, and so round(0.15, 1) could be either 0.1 or 0.2). To implement what we consider normal rounding we can install use the janitor package and the function round_half_up library(janitor) janitor::round_half_up(c(-1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5)) #&gt; [1] -2 -1 1 2 3 4 5 If we do not have access to the package (or do not want to depend on the package) then we can implement3 round_half_up_v2 &lt;- function(x, digits = 0) { posneg &lt;- sign(x) z &lt;- abs(x) * 10 ^ digits z &lt;- z + 0.5 z &lt;- trunc(z) z &lt;- z / 10 ^ digits z * posneg } round_half_up_v2(c(-1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5)) #&gt; [1] -2 -1 1 2 3 4 5 technically there are more, see https://adv-r.hadley.nz/vectors-chap.html#atomic-vectors↩ See chapter 8.2 of the R Inferno for a more detailed discussion of interesting factor behaviour↩ see stackoverflow discussion for a discussion of the implementation↩ "]
]
