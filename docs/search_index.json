[
["index.html", "DfT Introduction to R Chapter 1 Why do we need another book? 1.1 Coding standards 1.2 Adding to the book", " DfT Introduction to R List of authors 2019-05-08 Chapter 1 Why do we need another book? R is a very flexible programming language, which inevitably means there are lots of ways to achieve the same result. This is true of all programming languages, but is particularly exaggerated in R which makes use of ‘meta-programming’. For example, here is how to calculate a new variable using standard R and filter on a variable: # Calculate kilometers per litre from miles per gallon mtcars$kpl &lt;- mtcars$mpg * 0.425144 # Select cars with a horsepower greater than 250 &amp; show only mpg and kpl columns mtcars[mtcars$hp &gt; 250, c(&quot;car&quot;, &quot;mpg&quot;, &quot;kpl&quot;)] car mpg kpl 29 15.8 6.717275 31 15.0 6.377160 Here’s the same thing using Tidyverse style R: mtcars %&gt;% # Calculate kilometers per litre dplyr::mutate( kpl = mpg * 0.425144 ) %&gt;% # Filter cars with a horsepower greater than 250 dplyr::filter( hp &gt; 250 ) %&gt;% # Take only the car, mpg, and newly created kpl columns dplyr::select(car, mpg, kpl) car mpg kpl 29 15.8 6.717275 31 15.0 6.377160 These coding styles are quite different. As people write more code across the Department, it will become increasingly important that code can be handed over to other R users. It is much easier to pick up code written by others if it uses the same coding style you are familiar with. This is the main motivation for this book, to establish a way of coding that represents a sensible default for those who are new to R that is readily transferable across DfT. 1.1 Coding standards Related to this, the Data Science team maintain a coding standards document, that outlines some best practices when writing R code. This is not prescriptive and goes beyond the scope of this document, but might be useful for managing your R projects. 1.2 Adding to the book This book is not static - new chapters can be added and current chapters can be amended. If you want to edit or write a chapter for the book, check out the GitHub page. "],
["intro.html", "Chapter 2 Introduction", " Chapter 2 Introduction will go here "],
["data-import.html", "Chapter 3 Data Importing/Exporting and interaction with other programmes", " Chapter 3 Data Importing/Exporting and interaction with other programmes This chapter is for code examples of data importing/exporting and interactions with other programmes. "],
["variables.html", "Chapter 4 Vector basics 4.1 Vector types 4.2 Coercion 4.3 Working with dates 4.4 Working with factors 4.5 Rounding", " Chapter 4 Vector basics 4.1 Vector types There are four main atomic vector types that you are likely to come across when using R1; logical (TRUE or FALSE), double (3.142), integer (2L) and character (&quot;awesome&quot;) v1 &lt;- TRUE typeof(v1) #&gt; [1] &quot;logical&quot; v1 &lt;- FALSE typeof(v1) #&gt; [1] &quot;logical&quot; v2 &lt;- 1.5 typeof(v2) #&gt; [1] &quot;double&quot; v2 &lt;- 1 typeof(v2) #&gt; [1] &quot;double&quot; # integer values must be followed by an L to be stored as integers v3 &lt;- 2 typeof(v3) #&gt; [1] &quot;double&quot; v3 &lt;- 2L typeof(v3) #&gt; [1] &quot;integer&quot; v4 &lt;- &quot;Awesome&quot; typeof(v4) #&gt; [1] &quot;character&quot; As well as the atomic vector types you will often encounter two other vector types; factor and Date. Factor vectors are used to represent categorical data. They are actually integer vectors with two additional attributes, levels and class. At this stage it is not worth worrying to much about what attribute are just understand that, for factors, the levels attribute gives the possible categories and combined with the integer values works much like a lookup table. The class attribute is just “factor”. ratings &lt;- factor(c(&quot;good&quot;, &quot;bad&quot;, &quot;bad&quot;, &quot;amazing&quot;)) typeof(ratings) #&gt; [1] &quot;integer&quot; attributes(ratings) #&gt; $levels #&gt; [1] &quot;amazing&quot; &quot;bad&quot; &quot;good&quot; #&gt; #&gt; $class #&gt; [1] &quot;factor&quot; Date vectors are just double vectors with an additional class attribute set as “Date”. Note - The following borrows directly from Hadley’s Advanced R site so we need to attribute appropriately and use correct licence today &lt;- Sys.Date() typeof(today) #&gt; [1] &quot;double&quot; attributes(today) #&gt; $class #&gt; [1] &quot;Date&quot; The value of the double (which can be seen by stripping the class), represents the number of days since “1970-01-01”2: date &lt;- as.Date(&quot;1970-02-01&quot;) unclass(date) #&gt; [1] 31 4.2 Coercion 4.2.1 Conversion between atomic vector types Converting between the atomic vector types is done using the as.character, as.integer, as.logical and as.double functions. value &lt;- 1.5 as.integer(value) #&gt; [1] 1 as.character(value) #&gt; [1] &quot;1.5&quot; as.logical(value) #&gt; [1] TRUE Where it is not possible to convert a value you will get a warning message value &lt;- &quot;z&quot; as.integer(value) #&gt; Warning: NAs introduced by coercion #&gt; [1] NA When combining different vector types, coercion will obey the following hierarchy: character, double, integer, logical. typeof(c(9.9, 3L, &quot;pop&quot;, TRUE)) #&gt; [1] &quot;character&quot; typeof(c(9.9, 3L, TRUE)) #&gt; [1] &quot;double&quot; typeof(c(3L, TRUE)) #&gt; [1] &quot;integer&quot; typeof(TRUE) #&gt; [1] &quot;logical&quot; 4.2.2 Conversions with factors Unfortunately factors can be tricky to work with and their behaviour is not always obvious. Below we illustrate a couple of things to bear in mind when working with them. Firstly concatenating factors may not work as intended: my_factor &lt;- factor(c(&quot;bob&quot;, &quot;george&quot;, &quot;bob&quot;)) my_vector &lt;- c(my_factor, my_factor) my_vector #&gt; [1] 1 2 1 1 2 1 instead we would first need to convert to a character vector my_vector_2 &lt;- c(as.character(my_factor), as.character(my_factor)) my_vector_2 #&gt; [1] &quot;bob&quot; &quot;george&quot; &quot;bob&quot; &quot;bob&quot; &quot;george&quot; &quot;bob&quot; Secondly, we may sometimes find a numeric vector is being stored as a factor: df &lt;- read.csv(&quot;data/factor_example.csv&quot;) my_vector &lt;- df[[2]] typeof(my_vector) #&gt; [1] &quot;integer&quot; my_vector #&gt; [1] #N/A #N/A 1 2 3 1 #N/A #N/A #N/A #&gt; Levels: #N/A 1 2 3 to transform this to a numeric variable we can proceed as follows my_vector_2 &lt;- as.numeric(levels(my_vector)[my_vector]) #&gt; Warning: NAs introduced by coercion typeof(my_vector_2) #&gt; [1] &quot;double&quot; my_vector_2 #&gt; [1] NA NA 1 2 3 1 NA NA NA 4.3 Working with dates NOT FINISHED - need to write about lubridate 4.4 Working with factors NOT FINISHED - need to write about forcats 4.5 Rounding For rounding numerical values we have the function round(x, digits = 0). This rounds the value of the first argument to the specified number of decimal places (default 0). round(c(-1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5)) #&gt; [1] -2 0 0 2 2 4 4 This probably looks different to what you were expecting as at school we were generally taught that when rounding a 5 we go up if a positive value and down if a negative value. R, however, implements a different standard. We can see this by looking at the documentation (?round) Note that for rounding off a 5, the IEC 60559 standard (see also ‘IEEE 754’) is expected to be used, ‘go to the even digit’. Therefore round(0.5) is 0 and round(-1.5) is -2. However, this is dependent on OS services and on representation error (since e.g. 0.15 is not represented exactly, the rounding rule applies to the represented number and not to the printed number, and so round(0.15, 1) could be either 0.1 or 0.2). To implement what we consider normal rounding we can install use the janitor package and the function round_half_up library(janitor) janitor::round_half_up(c(-1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5)) #&gt; [1] -2 -1 1 2 3 4 5 If we do not have access to the package (or do not want to depend on the package) then we can implement3 round_half_up_v2 &lt;- function(x, digits = 0) { posneg &lt;- sign(x) z &lt;- abs(x) * 10 ^ digits z &lt;- z + 0.5 z &lt;- trunc(z) z &lt;- z / 10 ^ digits z * posneg } round_half_up_v2(c(-1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5)) #&gt; [1] -2 -1 1 2 3 4 5 technically there are more, see https://adv-r.hadley.nz/vectors-chap.html#atomic-vectors↩ This special date is known as the Unix Epoch↩ see stackoverflow discussion for a discussion of the implementation↩ "],
["tables.html", "Chapter 5 Table/Data Frame manipulation 5.1 Pivot and reshape tables 5.2 Dropping and selecting columns 5.3 Filtering data 5.4 Get counts of data 5.5 Combine tables 5.6 Joining tables 5.7 Select specific columns in a join 5.8 Sum rows or columns 5.9 Replace NAs or other values 5.10 Creating new variables 5.11 Summarising data 5.12 Look up tables", " Chapter 5 Table/Data Frame manipulation This chapter provides an overview of code examples for table or data frame manipulation (a tidyverse data frame is referred to as a tibble). One of the main things you will have to do in any R project or RAP project will be manipulating the data that you are using in order to get it into the format you require. One of the main packages used to manipulate data is the dplyr package which we recommend and use throughout this book. The dplyr package (and others e.g. tidyr) are all part of the tidyverse. The tidyverse is a group of packages developed by Hadley Wickham and others and are all designed to work with each other. See https://www.tidyverse.org/ for more info. Tidyverse packages and functions can be combined and layered using the pipe operator %&gt;%. Dplyr is built to work with tidy data. To find out more about tidy data please look at the following link https://r4ds.had.co.nz/tidy-data.html but the general principles are: Each variables must have its own column Each observation must have its own row Each value must have its own cell 5.1 Pivot and reshape tables There will be two examples for pivoting tables provided: The tidyr package uses the gather/spread functions and is often used to create tidy data The reshape2 package is also a useful package to pivot tables and has added functionality such as providing totals of columns etc. We want to have the day of the week variable running along the top so each day of the week is its own column. Table 5.1: Number of road accidents by accident severity and weekday Accident_Severity Day_of_Week n 1 1 300 1 2 205 1 3 187 1 4 233 1 5 220 1 6 250 Tidyr package Using the tidyr package, gather and spread functions can be used to pivot the table views: gather makes wide data longer i.e. variables running along the top can be “gathered” into rows running down. spread makes long data wider i.e. one variable can be spread and run along the top with each value being a variable. # Pivot table using tidyr package library(tidyr) road_accidents_weekdays &lt;- road_accidents_small %&gt;% tidyr::spread(Day_of_Week, n) With the spread function above you need to first specify the variable you want to spread, in this case Day_of_Week, and then the variable that will be used to populate the columns (n). Table 5.2: Number of road accidents by accident severity and weekday, tidyr::spread Accident_Severity 1 2 3 4 5 6 7 1 300 205 187 233 220 250 281 2 3009 2948 3230 3227 3246 3649 3225 3 11668 14783 16065 15859 16331 17346 13720 The opposite can also be done using the gather function: GET HELP ON THIS # Pivot table using tidyr package library(tidyr) road_accidents_gather &lt;- road_accidents_weekdays %&gt;% tidyr::gather(Accident_Severity, n, 1:7) Reshape2 package Again, this has two functions which can be used to pivot tables: melt makes wide data longer dcast makes long data wider # Pivot table using reshape2 package library(reshape2) road_accidents_weekdays2 &lt;- reshape2::dcast(road_accidents_small, Accident_Severity ~ Day_of_Week, value.var = &quot;n&quot;) With the dcast function above, after stating the name of the data frame, you need to specify the variable(s) you want in long format (multiple variables seperated by “+”), in this case Accident_Severity, and then the wide format variable(s) are put after the tilda (again multiple seperated by “+”). The value.var argument specifies which column will be used to populate the new columns, in this case it is n. Table 5.3: Number of road accidents by accident severity and weekday, reshape2::dcast Accident_Severity 1 2 3 4 5 6 7 1 300 205 187 233 220 250 281 2 3009 2948 3230 3227 3246 3649 3225 3 11668 14783 16065 15859 16331 17346 13720 If you want to create sums and totals of the tables this can also be done using reshape2. For example, taking the original table, we want to pivot it and sum each severity to get the total number of accidents per day. # Pivot table using reshape2 package library(reshape2) road_accidents_weekdays3 &lt;- reshape2::dcast(road_accidents_small, Accident_Severity ~ Day_of_Week, value.var = &quot;n&quot;, sum, margins = &quot;Accident_Severity&quot;) In this example, we use the margins argument to specify what we want to combine to create totals. So we want to add all the accident severity figures up for each weekday. Before using margin you need to specify how the margins are calculated, in this case we want a sum. Alternative options are to calculate the length, i.e. the number of rows. Table 5.4: Number of road accidents by accident severity and weekday plus totals, reshape2::dcast Accident_Severity 1 2 3 4 5 6 7 1 300 205 187 233 220 250 281 2 3009 2948 3230 3227 3246 3649 3225 3 11668 14783 16065 15859 16331 17346 13720 (all) 14977 17936 19482 19319 19797 21245 17226 The opposite can also be done using the melt function. # Pivot table using reshape2 package library(reshape2) road_accidents_melt &lt;- reshape2::melt(road_accidents_weekdays2, id.vars = &quot;Accident_Severity&quot;, measure.vars = c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;), variable.name = &quot;Day_of_Week&quot;, value.name = &quot;n&quot;) For the melt function you need to specify: id.vars = “variables to be kept as columns” measure.vars = c(“variables to be created as one column”) variable.name = “name of created column using the measure.vars” value.name = “name of value column” Table 5.5: Number of road accidents by accident severity and weekday, reshape2::melt Accident_Severity Day_of_Week n 1 1 300 2 1 3009 3 1 11668 1 2 205 2 2 2948 3 2 14783 5.2 Dropping and selecting columns Use the dplyr select function to both select and drop columns. Select columns road_accidents_4_cols &lt;- road_accidents %&gt;% dplyr::select(acc_index, Accident_Severity, Date, Police_Force) Table 5.6: Four columns from road accidents 2017 acc_index Accident_Severity Date Police_Force 2017010001708 1 2017-08-05 1 2017010009342 3 2017-01-01 1 2017010009344 3 2017-01-01 1 2017010009348 3 2017-01-01 1 2017010009350 2 2017-01-01 1 2017010009351 3 2017-01-01 1 Drop columns Note that to drop columns the difference is putting a “-” in front of the variable name. road_accidents_3_cols &lt;- road_accidents_4_cols %&gt;% dplyr::select(-Police_Force) Table 5.7: Three columns from road accidents 2017 acc_index Accident_Severity Date 2017010001708 1 2017-08-05 2017010009342 3 2017-01-01 2017010009344 3 2017-01-01 2017010009348 3 2017-01-01 2017010009350 2 2017-01-01 2017010009351 3 2017-01-01 5.3 Filtering data Use the dplyr filter function to filter data. This example filters the data for slight severity accidents (accident severity 3). road_accidents_slight &lt;- road_accidents_4_cols %&gt;% dplyr::filter(Accident_Severity == 3) Table 5.8: Slight severity road accidents 2017 acc_index Accident_Severity Date Police_Force 2017010009342 3 2017-01-01 1 2017010009344 3 2017-01-01 1 2017010009348 3 2017-01-01 1 2017010009351 3 2017-01-01 1 2017010009353 3 2017-01-01 1 2017010009354 3 2017-01-01 1 To filter multiple conditions: And operator road_accidents_filter &lt;- road_accidents_4_cols %&gt;% dplyr::filter(Accident_Severity == 3 &amp; Police_Force == 4) Or operator road_accidents_filter2 &lt;- road_accidents_4_cols %&gt;% dplyr::filter(Accident_Severity == 3 | Accident_Severity == 2) Note: filtering with characters must be wrapped in “quotations” e.g: road_accidents_filter3 &lt;- road_accidents %&gt;% dplyr::filter(`Local_Authority_(Highway)` == &quot;E09000010&quot;) Also note that in the above example the variable is quoted in back ticks (`). This is because some variable names confuse R due to brackets and numbers and need to be wrapped in back ticks so R knows that everything inside the back ticks is a variable name. 5.4 Get counts of data To get counts for groups of data, the dplyr tally function can be used in conjunction with the dplyr group by function. This groups the data into the required groups and then tallys how many records are in each group. # Create grouped data set with counts road_accidents_small &lt;- road_accidents %&gt;% dplyr::group_by(Accident_Severity, Day_of_Week) %&gt;% dplyr::tally() The above example creates groups by accident severity and weekday and counts how many accidents are in each group (one row equals one accident therefore the tally is counting accidents). Table 5.9: Road accidents 2017 by accident severity and weekday Accident_Severity Day_of_Week n 1 1 300 1 2 205 1 3 187 1 4 233 1 5 220 1 6 250 5.5 Combine tables When combining data from two tables there are two ways to do this in R: Bind the tables by basically either appending the tables on the rows or columns Join the tables using the dplyr version of SQL joins Binding tables Binding tables is mainly done to append tables by creating more rows, however tables can also be binded by adding more columns. Although it is recommended to use the dplyr join functions to combine columns (see 5.6). Here are three tables, one shows data for accident severity of 1, one for accident severity of 2, and one for accident severity of 3. Table 5.10: Number of fatal road accidents in 2017, by weekday Accident_Severity Day_of_Week n 1 1 300 1 2 205 1 3 187 1 4 233 1 5 220 1 6 250 1 7 281 Table 5.10: Number of serious injury road accidents in 2017, by weekday Accident_Severity Day_of_Week n 2 1 3009 2 2 2948 2 3 3230 2 4 3227 2 5 3246 2 6 3649 2 7 3225 Table 5.10: Number of slight injury road accidents in 2017, by weekday Accident_Severity Day_of_Week n 3 1 11668 3 2 14783 3 3 16065 3 4 15859 3 5 16331 3 6 17346 3 7 13720 To combine these tables we can use the bind_rows function from the dplyr package. Use bind_rows when you want to append the tables underneath one another to make one longer table, i.e. you want to add more rows. Ensure that the column names for each table are exactly the same in each table. # combine tables using bind_rows library(dplyr) all_accidents &lt;- accidents_1 %&gt;% dplyr::bind_rows(accidents_2, accidents_3) Table 5.11: Road accident data 2017, bind_rows Accident_Severity Day_of_Week n 1 1 300 1 2 205 1 3 187 1 4 233 1 5 220 1 6 250 1 7 281 2 1 3009 2 2 2948 2 3 3230 2 4 3227 2 5 3246 2 6 3649 2 7 3225 3 1 11668 3 2 14783 3 3 16065 3 4 15859 3 5 16331 3 6 17346 3 7 13720 5.6 Joining tables Joins in R can be done using dplyr. This is generally to combine columns of data from two tables: # combine tables using left join library(dplyr) all_accidents_cols_join &lt;- road_acc_1 %&gt;% dplyr::left_join(road_acc_2, by = &quot;acc_index&quot;) This uses the same principles as SQL, by specifying what the tables should be joined on using the by = argument. Dplyr has all the usual SQL joins for example, inner_join, full_join, right_join. All of these are used in the same way as the left join example above. Another useful join for data manipulation is an anti_join. This provides all the data that is not in the joined table. For example, the below snapshot of a table displays road accident totals broken down by accident severity and weekday: Accident_Severity Day_of_Week n 1 1 300 1 2 205 1 3 187 1 4 233 1 5 220 1 6 250 I am interested in creating two sub-groups of this data, a table for all accidents on a Monday (weekday 2), and all other accidents. First, I get the Monday data using the dplyr filter function (see 5.3). Accident_Severity Day_of_Week n 1 2 205 2 2 2948 3 2 14783 Then, I can use an anti-join to create a table which has all of the data that is not in the above table: # create table of all rows not in the joined table library(dplyr) all_accidents_not_monday &lt;- road_accidents_small %&gt;% dplyr::anti_join(accidents_monday, by = c(&quot;Accident_Severity&quot;, &quot;Day_of_Week&quot;)) The above code takes the initial table we want to get our data from (road_accidents_small) and anti joins accidents_monday. This says, “get all the rows from road_accidents_small that are not in accidents_monday”. Again, note the need to specify what the join rows would be joined and compared by. Table 5.12: Road accident data 2017 not on a Monday by accident severity Accident_Severity Day_of_Week n 1 1 300 1 3 187 1 4 233 1 5 220 1 6 250 1 7 281 2 1 3009 2 3 3230 2 4 3227 2 5 3246 2 6 3649 2 7 3225 3 1 11668 3 3 16065 3 4 15859 3 5 16331 3 6 17346 3 7 13720 5.7 Select specific columns in a join Doing a join with dplyr will join all columns from both tables, however sometimes not all columns from each table are needed. Let’s look at some previous tables again: Table 5.13: Police force and accident severity information for accidents acc_index Police_Force Accident_Severity 2017010001708 1 1 2017010009342 1 3 2017010009344 1 3 2017010009348 1 3 2017010009350 1 2 2017010009351 1 3 Table 5.13: Date and weekday information for accidents acc_index Date Day_of_Week 2017010001708 2017-08-05 7 2017010009342 2017-01-01 1 2017010009344 2017-01-01 1 2017010009348 2017-01-01 1 2017010009350 2017-01-01 1 2017010009351 2017-01-01 1 Let’s say we want acc_index and Police_Force from the first table, and Date from the second table. # select specific columns from each table and left join library(dplyr) road_acc_3 &lt;- road_acc_1 %&gt;% dplyr::select(acc_index, Police_Force) %&gt;% dplyr::left_join(select(road_acc_2, acc_index, Date), by = &quot;acc_index&quot;) The above code takes the first table and uses the select statement to select the required columns from the first table. Then within the left_join command, to select the data from the second table, you again add the select statement. Note: you will need to select the joining variable in both tables but this will only appear once Table 5.14: Police force and Date information for specific accidents acc_index Police_Force Date 2017010001708 1 2017-08-05 2017010009342 1 2017-01-01 2017010009344 1 2017-01-01 2017010009348 1 2017-01-01 2017010009350 1 2017-01-01 2017010009351 1 2017-01-01 5.8 Sum rows or columns These solutions use the base R functions rather than dplyr. 5.8.1 Sum rows To sum across a row: # sum across a row road_accidents_weekdays$rowsum &lt;- rowSums(road_accidents_weekdays, na.rm = TRUE) Table 5.15: Road accidents 2017 by accident severity and weekday Accident_Severity 1 2 3 4 5 6 7 rowsum 1 300 205 187 233 220 250 281 1677 2 3009 2948 3230 3227 3246 3649 3225 22536 3 11668 14783 16065 15859 16331 17346 13720 105775 To sum across specific rows: # sum across specific rows road_accidents_weekdays$alldays &lt;- road_accidents_weekdays$`1` + road_accidents_weekdays$`2`+ road_accidents_weekdays$`3`+ road_accidents_weekdays$`4`+ road_accidents_weekdays$`5`+ road_accidents_weekdays$`6`+ road_accidents_weekdays$`7` Table 5.16: Road accidents 2017 by accident severity and weekday Accident_Severity 1 2 3 4 5 6 7 alldays 1 300 205 187 233 220 250 281 1676 2 3009 2948 3230 3227 3246 3649 3225 22534 3 11668 14783 16065 15859 16331 17346 13720 105772 5.8.2 Sum columns To sum columns to get totals of each column, note this will appear as a console output not in a data object: # sum columns colSums(road_accidents_weekdays, na.rm = TRUE) To get the totals of each column as a row in the data: library (janitor) # create total column road_accidents_weekdays &lt;- road_accidents_weekdays %&gt;% janitor::adorn_totals(&quot;row&quot;) Table 5.17: Road accidents 2017 by accident severity and weekday Accident_Severity 1 2 3 4 5 6 7 1 300 205 187 233 220 250 281 2 3009 2948 3230 3227 3246 3649 3225 3 11668 14783 16065 15859 16331 17346 13720 Total 14977 17936 19482 19319 19797 21245 17226 Reshape2 can also be used to get column totals when pivoting a table (See 5.1). 5.9 Replace NAs or other values To replace all NAs in one column (Junction Control column) with a specific value: library (tidyr) # replace all NAs with value -1 road_accidents_na$Junction_Control &lt;- road_accidents_na$Junction_Control %&gt;% tidyr::replace_na(-1) Note: To replace NA with a character the character replacement must be wrapped in “quotations” To replace all NAs in a data frame or tibble: # replace all NAs with value -1 road_accidents_na &lt;- road_accidents_na %&gt;% replace(is.na(.), -1) To replace values with NA, specify what value you want to be replaced with NA using the na_if function: # create nas road_accidents_na &lt;- road_accidents_na %&gt;% dplyr::na_if(-1) Note: to only create NAs in a specific column specify the column name in a similar manner to the first example in this section. To replace values: # replace 1st_road_class road_accidents_na &lt;- road_accidents_na %&gt;% dplyr::mutate(`1st_Road_Class` = dplyr::case_when(`1st_Road_Class` == 3 ~ &quot;A Road&quot;, TRUE ~ as.character(`1st_Road_Class`))) The case_when function is similar to using CASE WHEN in SQL. The TRUE argument indicates that if the values aren’t included in the case_when then they should be whatever is after the tilda (~) i.e. the equivalent of the ELSE statement in SQL. The “as.character” parameter says that everything that isn’t 3 should be kept as it is, this could be replaced by an arbitrary character or value e.g. “Other”. This would make everything that is not a 3, coded as “Other”. You can have multiple case_when arguments for multiple values, they just need to be seperated with a comma. Multiple case_when statements for different variables can be layered using the pipe operator %&gt;%. 5.10 Creating new variables 5.11 Summarising data 5.12 Look up tables "],
["plots.html", "Chapter 6 Plotting and Data Visualisations", " Chapter 6 Plotting and Data Visualisations This chapter is for code examples of plotting and visualising data. "],
["stats.html", "Chapter 7 Statistical analysis", " Chapter 7 Statistical analysis This chapter is for code examples of statistical analysis. "],
["advanced.html", "Chapter 8 Advanced", " Chapter 8 Advanced This chapter is for code examples of advanced and further R concepts. "]
]
